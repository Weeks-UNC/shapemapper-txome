#!/usr/bin/env python

'''

'''

# NOTE: kallisto discards read ID past the first whitespace char, so
#       these wrappers also adhere to that convention

# NOTE: explicit fragment length is required when using single-end reads, and/or
# when applying a filter on minimum estimated mean coverage ('--min-mean-coverage' > 0)

import datetime
start_time = datetime.datetime.now()

import sys, os, glob, shutil
import subprocess as sp

from scripts.logger import Logger
from scripts.job_wrapper import Job, run_jobs, stage
from scripts.parse_args import parse_args
from scripts.util import timestamp, makedirs
from scripts.globals import god

THIS_DIR = os.path.split(os.path.realpath(__file__))[0]
RUN_TEST = True

if RUN_TEST:
    args = '''
            --paired
            --modified test_data/modified
            --untreated test_data/untreated
            --multimapper-mode random
            --platform local
            --min-reads 10
            --out results_random
            --target test_data/16S.fa test_data/23S.fa test_data/TPP.fa test_data/U1.fa
            '''.strip().split()
else:
    args = sys.argv[1:]

p = parse_args(args)

outlog_path = p.out+"/"+"kallisto-wrapper_log.txt"
outlog = Logger(outlog_path,
                sys.stdout)
# override stdout and stderr globally to redirect through logger
sys.stdout = outlog
sys.stderr = outlog

print("Started kallisto-wrapper at {}".format(timestamp()))
print("arguments = {}".format(p))
print("Will write all output to {}.".format(p.out))
makedirs(p.out)

# parameters used in job_wrapper.py functions
god.platform = p.platform
god.max_jobs = p.max_jobs


# -----------------------------------------------------------------------------
# generate kallisto index
dir = p.out+"/kallisto_index"
cmd = 'kallisto index -i {dir}/index {target}'.format(dir=dir,
                                                        target=' '.join(p.target))
stage(name="kallisto index building",
      dir=dir,
      done=dir+"/kallisto_index_done",
      cmd=cmd)


# -----------------------------------------------------------------------------
# run pseudomapping
prev_dir = dir
dir = p.out+"/kallisto_pseudomap"
extra_flags = '--single --fragment-length {fragment_length} --sd {fragment_sd}'
extra_flags = extra_flags.format(fragment_length=p.fragment_length,
                                 fragment_sd=p.fragment_sd)
if p.paired:
    extra_flags = ''
cmds = []
for sample in p.input_files.keys():
    if len(p.input_files[sample]) == 0:
        continue
    cmd = ('kallisto quant -i {prev_dir}/index --pseudobam --plaintext '
           '-o {dir}/kallisto_quant_{sample} {inputs} {extra_flags}')
    cmd = cmd.format(dir=dir,
                     prev_dir=prev_dir,
                     target=' '.join(p.target),
                     sample=sample,
                     inputs=' '.join(p.input_files[sample]),
                     extra_flags=extra_flags)
    cmds.append(cmd)

stage(name="kallisto pseudomapping to targets",
      dir=dir,
      done=dir+"/kallisto_pseudomap_done",
      cmds=cmds)

kallisto_dir = dir

# -----------------------------------------------------------------------------
# identify transcripts above some potential coverage threshold

dir = p.out+"/filter_targets"
cmd = (
    '{THIS_DIR}/scripts/filter_target_coverage.py '
    '--in {input_args} '
    '--out {dir}/ids.txt '
    '--min-reads {min_reads} '
    '--min-mean-coverage {min_mean_coverage} '
    '--frag-len {frag_len} '
       )
input_args = ''
for sample in p.input_files.keys():
    if len(p.input_files[sample]) == 0:
        continue
    input_args += (
        '{kallisto_dir}/kallisto_quant_{sample}/abundance.tsv '.format(
            kallisto_dir=kallisto_dir, sample=sample
        )
    )
cmd = cmd.format(
    THIS_DIR=THIS_DIR,
    dir=dir,
    input_args=input_args,
    min_reads = p.min_reads,
    min_mean_coverage= p.min_mean_coverage,
    frag_len = p.fragment_length,
)

stage(name="target coverage filtering",
      dir=dir,
      done=dir+"/filter_targets_done",
      cmd=cmd)


# -----------------------------------------------------------------------------
# generate fasta with selected transcripts only


# -----------------------------------------------------------------------------
# convert bam to SAM for simpler parsing
# {kallisto_dir}/kallisto_quant_{sample}/pseudoalignments.bam


# -----------------------------------------------------------------------------
# split sam file(s) into FASTQ or pairs of FASTQ files for each selected target transcript

# -----------------------------------------------------------------------------
# run shapemapper on each batch of reads and associated target sequence


# -----------------------------------------------------------------------------
end_time = datetime.datetime.now()
delta = end_time - start_time
hours, remain = divmod(delta.seconds, 3600)
minutes, seconds = divmod(remain, 60)
print("\nkallisto-wrapper completed. Total turnaround time {} hours, {} minutes, {} seconds".format(
       hours, minutes, seconds))